"""Spiral Galaxies

Galactic rotation curves without dark matter.

**A new paradigm for the universe.**

https://msp.warwick.ac.uk/~cpr/paradigm

ISBN: 9781973129868

I keep dipping into this book.

Each time with new understanding.  Each time with a new perspective.

It is a wonderful work, with compelling arguments.

Chapter 2, Sciama's principle finishes with:

   Sciama's initiative, to base a dynamical theory on Mach's principle as
   formulated in Sciama's principle, has never been followed up and this
   approach to dynamics remains dormant.  One of the aims of this book is to
   reawaken this approach.

One of the aims of `blume` is to help understanding of such theories.

In particular, help my own understanding with computer simulations.

This project will explore some of the mathematics of the book.

It will require `astropy`.  

Solar system, galactic and local galaxy visualsation and simulation.

Simulation of gravitational waves generated by black hole mergers using the
physics of *the book*.

Simulations of gravitational wave from a new galactic arrival.

2021 update
===========

The Geometry of the Universe

Colin Rourke

https://www.worldscientific.com/worldscibooks/10.1142/12195

ISBN: 978-981-123-386-9 (hardcover)

A new book, with a bold claim.  A stunning story, a revival of some
old ideas and new brilliance too.


Spiral
======

Spiral galaxies?  Why spirals?

The problem noted by observational scientist Vera Rubin was that stars
in the outer reaches of spiral galaxies are moving far too fast.

This observation is what lead to the dark matter assumption: there
must be some matter we can't see that is dragging the stars along.

Colin Rourke, says nonesense, there must be a giant rotating mass at
the centre, dragging things along.


Einstein's general relativity withstands double pulsar's Scrutiny
=================================================================

https://physics.aps.org/articles/v14/173

Strong-Field Gravity Tests with the Double Pulsar

M. Kramer et al.

Phys. Rev. X 11, 041050 (2021)

Published December 13, 2021

Binary pulsars provide strong tests of general relativity.  The idea
is that there are two, rapidly rotating, neutron stars in a close
orbit around each other.

The Hulse-Taylor binary system has long been the best observed system
and the strongest test.

A new system *PSR J0737-3039A/B* has now taken that crown as the best
observed system.  Lets call it Jumb0 737, from the J designate, or
Jumbo for short.

The rotations of the Jumbo are incredibly stable, at the level of an
atomic clock, allowing very precise measurements of the time delays of
the pulses of energy as the system makes each rotation.

In addition, Jumbo is nearer than the Hulse-Taylor system and there is
much less uncertainty in our estimate of its distance from earth.

It all gets complicated, since as although the system is in our own
galaxy, the intervening spacetime modulates the signal we receive.

The new paper explains the precise measurements that can now be made
and how variations on general relativity, can, in some cases, be
tested.

In particular, the paper now mentions that rotation of the faster
rotating body now has to be taken into account in the equations of
state of the entire system.  The other body is rotating around one
hundred times slower so the effect can largely be ignored.

The aproach that is taken is to assume the Lense-Thiring effect.  

This is discussed in some detail in chapter 3 of the book, *the
biggest blunder...*.  Particular attention should be paid to the
discussion around page 60.

There are some quite technical arguments.  The Lense Thiring effect is
intuitively compelling.  General relativity tells us that if
*space-time is a vacuum*, then the Kerr metric is the only solution
that fits Einstein's equations.

This is problematic for the book's arguments as the Kerr metric falls
off as 1/(r**3) whereas the book argues it should fall off as 1/r.

Rourke makes the assumption that linear motion has no inertial effect
and notes that you can change angular momentum by adding a linear
motion, whereas angular velocity cannot be changed in this way.

Is space time a vacuum?
-----------------------

The impasse is resolved if we assume that space is not in fact a
vacuum.

For starters, there is an awful lot of microwave radiation buzzing
around:  the cosmic microwave background.

The nature of this background depends critically on our assumptions
about the geometry of the universe: big bang, or static universe?

What would a static universe look like given the effects of special
relativity, simplifying a universe to the set of galaxies above a
certain size?

This model will instead show how by assuming this 1/r relation for the
effect of a masses rotation on its surroundings, produces galactic
rotation curves very much in line with observations.

What about Jumbo?
=================

So the cool news is that we now get estimates of the angular velocity
of each body and it's moment of inertia.

The latter adds some uncertainty to model fit as there is uncertainty
of the exact distribution of the matter within each neutron star,
which is important to know, as the model being used assumed it is
angular momentum that drives the rotational frame dragging.

As noted above, Rourke argues that it is angular velocity, rather than
angular momentum that matters in the calculation, in short the matter
distribution within the black hole is not required for his model.

Further, that the Lense-Thiring effect drops off as 1/r, not the
1/r**3 that is presumably being used by the new paper.  Unless the
orbits are highly oblique, this difference is not going to be
detectable with a single system.

This should mean that a fit using Rourke's model reduces the
uncertainty in all the parameters that the fitting process estimates,
since the uncertainty in the matter distribution no longer comes into
play, just the uncertainty in angular velocity.

Another project would be to fit the model to the latest Hulse-Taylor
data and see what changes.

I am also curious how Rourke's model affects the long term evolution
of these systems.  My hunch (actually I think I read something along
these lines in the book) is that the feedback from the rotation keeps
these binary systems stable and that it is highly improbable that they
will in-spiral and coalesce.   

Which raises the interesting question of what is the source of the
waves that our gravitational wave detectors are seeing?   

Which reminds me, I need to work on the grb module.


What about the spiral module?
=============================

The idea is to create a visualisation of the formation of spiral
galaxies with a *\omega m / r* model.

It would be good to also be able to model binary systems while we are at it.

"""

import argparse

import random

import math
import statistics

from collections import deque

from pathlib import Path

import astropy.units as u
import astropy.constants as c
import astropy.coordinates as coord
from astropy import cosmology

from blume import magic
from blume import farm as fm
from blume import taybell

from matplotlib import pyplot as plt
from matplotlib import colors

import numpy as np

from scipy import integrate

from gotu import sd

def mass_length():
    """ Equivalence of mass and length based on Schwartzchild radius

    This is for use with astropy constants.

    for example:
    >>> u.solMass.compose(mass_length())
    
    """
    ee = [u.kg, u.m, lambda x: (2 * x * c.G / (c.c * c.c)).value, lambda x:(c.c * c.c * x / (2 * c.G)).value]

    def kgtom(x):

        return (2 * x * c.G / (c.c * c.c)).value
    
    def mtokg(x):

        return (c.c * c.c * x / (2 * c.G)).value

    return u.Equivalency([
        [u.kg, u.m, kgtom, mtokg]], 'mass_length')


    

def planck_radiance_law_wavelength(wavelength, T=None):
    """ Energy emitted in wavelength at temperature T

    wavelength: a float, wavelength in meters
    T: temperature, a quantity with units K
    
    returns astropy Quantity object with units
    """
    if T is None:
        T = Cosmo().Tcmb0
    
    hh = c.h
    cc = c.c
    ee = math.exp
    kT = c.k_B * T
    lam = wavelength * u.meter
    #print(lam)
    #print(h*c/lam*kT)
    # in terms of frequency v
    blam = (2*hh*cc**2/(lam**5)) / (ee(hh*cc/(lam*kT)) - 1)

    return blam.value


def hubble_tension(cmb=cosmology.Planck18.H0, near=None):
    """ Explore hubbe tension """

    if near is None:
        # I should calculate this based on the full model
        near = 73 * u.km / (u.Mpc * u.s)

    return near - cmb

class Cosmo:
    """Mimic an astropy Cosmology object

    It's a Sciama-DeSitter Universe.

    Static, but doesn't look static.

    Old and big in a state of equilibrium.

    The O*0 attributes give the current estimates of the share of the
    critical mass (also at z=0) in various buckets.

    Ogamma for photons (primarial CMB)
    Om for non-realtivistic matter
    Ob for baryonic
    Odm for dark matter.
    Ode for dark energy.

    Dark matter is not part of this cosmology.

    Instead assume this turns up as black holes in
    the centre of galaxies.

    """

    def __init__(self, cosmo=None):

        cosmo = cosmo or cosmology.default_cosmology.get()

        # Our Cosmos is essentially static so all these
        # Omega values are the same regardless of z
        # Code below is magic to set up these functions
        for attr in dir(cosmo):
            if attr.endswith('0'):
                def f(z, attr=attr):
                    return getattr(self, attr)

                setattr(self, attr, getattr(cosmo, attr))
                setattr(self, attr[:-1], f)

    @property
    def hubble_distance(self):

        htime = (1/self.H0).to(u.year)

        distance = htime.value * u.lightyear

        return distance

    def check_critical_density(self):
        """ Critical density formulae

        The critical density only depends on the Hubble distance.

        It is the mass per unit volume such that the total mass has
        Schwartzchild radius equal to the Hubble distance.

        As such, it is determined by the Hubble constant.
        """
        pi = math.pi
        hd = self.hubble_distance << u.m
        cd = self.critical_density0 << u.kg / u.m**3

        # mass of the universe [1]
        M = cd * (4/3) * pi * hd * hd * hd
        print(hd)
        print(cd)
        print(M)
        
        # Schwartzchild radius
        print((c.G * 2 * M / (c.c * c.c)) << u.m)
        # hd = 2 * M * c.G / (c.c * c.c)
        # M = hd * c.c * c.c / (2 * c.G)

        sc = (c.G * 2 * (cd * (4/3) * pi * hd * hd * hd) / (c.c * c.c))
        
        # substitute from [1]
        cd2 = (3/4) * c.c * c.c / (2 * c.G * hd * hd * pi)
        print(cd, cd2, M)
    
    def is_flat(self):
        """ Not sure what the answer is to this.

        Perhaps, "asymptotically flat"?
        """

        return None

class SkyMap(magic.Ball):
    """Yet another table viewer? 

    parsing csv and figuring out what it means.

    or just give me lists of fields i can pick form for
    any purpose?

    Or yet another universe viewer.

    And so we descend into the world of coordinate systems.

    Something astronomers understand very well.
    
    See :mod:`gotu.wits` for more on this subject.

    Maybe SkyMap allows systems to evolve over time, according to the
    paradigm.

    """

    def __init__(self, gals=None):

        super().__init__()

        if gals is None:
            try:
                print('calling near_galaxies')
                gals = [from_heasarc(x) for x in near_galaxies()]
            except:
                gals = list(sample_galaxies())
        
        self.balls = gals
        self.offset = 0.

        # set defaults from Cosmo object
        cosmo = Cosmo()
        self.cosmo = cosmo

        # Conversion factor from stellar mass to black hole mass
        # Assume the dark matter and dark energy turn up as central
        # galactic black holes.
        # more conservative, just use the dark matter.
        # self.m_bh = (cosmo.Ode0 + cosmo.Odm0) / cosmo.Ob0
        self.m_bh = cosmo.Odm0 / cosmo.Ob0

        # the CMB is 45 times brighter than you would expect based
        # on size of visible universe.  Hitchhikers should note
        # that setting fudge to 42 produces a viable model.
        self.fudge = 45.

        # wavelength factor relative to Schwartzchild radius
        self.sfactor = 10

        # Conversion from Holmberg radius mass to full stellar mass
        self.minmass = 6.  # min mass to include, log10(solar_mass)
        mean_sample_mass = self.sample_mass()

        hd = cosmo.hubble_distance << u.m
        volume_of_universe = (4/3) * math.pi * (hd**3)
        self.volume_of_universe = volume_of_universe
        critical_density = cosmo.critical_density0 << u.kg / u.m**3
        mass_of_universe = critical_density * volume_of_universe
        self.mass_of_universe = mass_of_universe

        # we want to scale things up to cosmo.Ob0
        stellar_mass = cosmo.Ob0 * mass_of_universe << u.solMass

        # Given number of galaxies, we can get the factor needed to scale
        # the sample mass up to stellar_mass
        self.N = 1e11
        
        self.h_factor = (stellar_mass / self.N) / mean_sample_mass

        self.period = 30    # years

        self.cmb_min = 1e-4  # u.m
        self.cmb_max = 0.004 # u.m

        # local simulation only
        self.max_distance = 1e8 * u.lightyear

        # initialise Mcent -- done this way because we need
        # to calculate h_factor based on mean sample mass
        self.set_mcent()

    def set_mcent(self):
        """ Set up central mass based on stellar mass """

        for gal in self.balls:

            stellar = (schwartzchild(c.M_sun) * gal.Mstellar) << u.lightyear
            black_hole = stellar.value * self.h_factor * self.m_bh

            gal.Mcent = black_hole

    def sample_mass(self):
        """ Return the sum of the masses of the sample

        In solar masses.
        """
        mass = 0
        total = 0
        for gal in self.balls:
            m26 = gal.Mstellar
            if math.log10(m26) < self.minmass:
                continue

            total += 1
            mass += m26

        return mass / total << u.solMass

    async def local_mode_sim(self):
        """ Simulation of the gravity waves from the local cluster """

        wavelengths = []
        amps = []
        for gal in self.balls:
            if not gal.Mstellar: continue

            distance = gal.distance
            
            if distance > self.max_distance: continue

            stellar_mass = self.h_factor * gal.Mstellar
            black_hole = gal.lightyear_to_kg()
            
            sc = (2 * black_hole * c.G / (c.c*c.c)) << u.lightyear

            wavelengths.append(sc.value)
            amps.append((sc / distance).value)

        points, wave = waves(
            amps, wavelengths,
            period=self.period)
        
        ax = await self.get()
        ax.plot(points, wave)
        ax.set_title('Local Gravitational Wave Background')
         
        ax.show()

    def waves(self):
        """ What waves would be generated by the catalog? """

        sample = []
        total_mass = 0.
        for gal in self.balls:
            stellar = gal.Mstellar
            name = gal.name

            if math.log10(stellar) < self.minmass:
                continue

            sample.append(gal)

            bh = gal.lightyear_to_kg() / c.M_sun
            
            total_mass += bh.value + stellar


        print('total mass',  math.log10(total_mass), total_mass * c.M_sun)

        mean_mass = math.log10(total_mass / len(sample))
        print('mean mass', mean_mass)
        print('sample size', len(sample))

        print(f'total mass given {self.N} galaxies',
              self.N * 10**mean_mass * c.M_sun)

        mou = self.mass_of_universe
        print("number of galaxies based on mbocd",
              f'{mou / (c.M_sun * total_mass/len(sample)):.2e}')

        # weight for each galaxy
        weight = self.N / len(sample)
        R = self.cosmo.hubble_distance << u.m

        for gal in sample:
            sc = gal.schwartzchild() << u.m
            gal.amplitude = 1.5 * (weight * sc)/R
        return sample

    def decra2rad(self, dec, ra):

        return math.radians(dec), math.radians(ra)

        ra = (ra - 12) * math.pi / 12.

        while ra > math.pi:
            ra -= 2 * math.pi
        
        return dec * math.pi / 180., ra
        

    def spinra(self, ra):

        ra += self.offset
        while ra > math.pi:
            ra -= 2 * math.pi

        while ra < math.pi * -1:
            ra += 2 * math.pi

        return ra

    async def log10hist(self, values, n=10, title=None):

        ax = await self.get()
        ax.hist([math.log10(x) for x in values])

        ticks = ax.get_xticks()
        ax.set_xticklabels([10**x for x in ticks])
        ax.set_title(title)
        ax.show()
        
    async def run(self):

                
        #ax = fig.add_axes((0,0,1,1), projection='mollweide')
        ax = await self.get()
        ax.projection('mollweide')

        locs = [self.decra2rad(ball.dec, ball.ra)
                    for ball in self.balls]

        ball_colours = [x.distance.value for x in self.balls]

        ax.set_facecolor('black')
        ax.scatter([self.spinra(xx[1]) for xx in locs],
                   [xx[0] for xx in locs],
                   c=ball_colours,
                   s=[math.log10(x.Mstellar) or 1
                      for x in self.balls])

        ax.axis('off')

        ax.show()

        ax = await self.get()

        sample = self.waves()

        ax.set_title('Schwartzchild v amplitude')
        ax.scatter([x.schwartzchild().value for x in sample],
                   [x.amplitude.value for x in sample])
        ax.show()

        await self.log10hist(
            [x.amplitude.value * self.fudge for x in sample],
            title='Amplitude(m)')

        await self.log10hist(
            [x.schwartzchild().value for x in sample],
            title='Schwartzschild (lightyear)')
        
        ax = await self.get()
        ax.hist([math.log10(x.lightyear_to_kg() / c.M_sun) for x in sample])
        ax.set_title('Black hole mass (log10(suns))')
        ax.show()
        
        ax = await self.get()
        ax.scatter([x.Mcent for x in sample],
                   [x.amplitude.value for x in sample])
        
        ax.set_title('Black hole mass v amplitude')
        ax.show()

        # try and simulate the wave
        period = self.period

        ax = await self.get()
        points, wave = waves(
            [x.amplitude.value * self.fudge for x in sample],
            [self.sfactor * x.schwartzchild().value for x in sample],
            period=self.period)
        
        ax.plot(points, wave)
        ax.set_title('Gravitational Wave Background')
         
        ax.show()

        await self.local_mode_sim()
        await self.cmbsim()
        await self.cmb_gwb()


    async def cmbsim(self):
        """ Calculate some CMB related numbers """

        # Mass per unit volume, based on critical density and Ogamma
        # Assumes CMB makes up the vast majority of photons.
        cosmo = self.cosmo
        cmb_mpuv = cosmo.Ogamma0 * cosmo.critical_density0 << u.kg/u.m**3
        print("CMB equivalent mass per unit volume", cmb_mpuv)
        
        # What is the energy 
        mwave = 1e-3 * u.m
        mass_mwave = c.h / (c.c * mwave)
        print(f"energy of {mwave} photon {mass_mwave}")
        print("photon density", cmb_mpuv / mass_mwave)

        # energy according to planck radiance
        energy, error = integrate.quad(
            planck_radiance_law_wavelength,
            self.cmb_min, self.cmb_max)
        
        # this should relate to cmb per unit volume
        # It is the energy per unit solid angle,
        #            per square meter per second.
        # so we want to scale by: 4 * math.pi / c.c
        cmb_energy_density = (4 * math.pi * energy / c.c).value
        print("Energy per cubic meter", cmb_energy_density)

        # mass equivalent
        mass_equiv = (cmb_energy_density / (c.c * c.c)).value

        cmbgamma = (mass_equiv /
                    self.cosmo.critical_density0.to(u.kg/u.m**3)).value
        # compare to critical density
        print("CMB fraction of critical, Ogamma", cmbgamma)
              
        print("Ogamm0", self.cosmo.Ogamma0)


    async def cmb_gwb(self):

        cosmo = self.cosmo
        
        # Simulate the gravitational waves that the CMB generates
        a, b = self.cmb_min * u.m, self.cmb_max * u.m
        
        wavelengths = np.linspace(a, b , 1000)

        # Planck radiance energy, converted to J/m3
        density = np.array(
            [planck_radiance_law_wavelength(x.value) / c.c.value
             for x in wavelengths])

        # convert to total CMB energy in universe
        energy = density * (self.volume_of_universe << u.m**3).value

        # Get Schwartzchild radiuses
        sc = np.array([
            (2 * c.G * c.h / (x * c.c**3)).value for x in wavelengths])

        # radius of visible universe in m
        R = cosmo.hubble_distance.to(u.m).value

        # total mass of CMB
        M = cosmo.Ogamma0 * self.mass_of_universe

        # Mass of single photon of each wavelength
        mass_per_photon = (c.h * c.c / wavelengths).to(
            u.kg, equivalencies=u.mass_energy())

        total_photons = energy / mass_per_photon
        # 4/3 pi R3 * energy -- rho 4 pi r2 

        # The effect integrated over volume of the universe 3M / 2R
        # the wave decays with 1/r, and we have to divide energy
        # by the volume
        energy = (sc * 3 * energy  / (2 * R))

        # can also calculate energy from density
        # energy2 = sc * 2 * math.pi * density * R * R
        
        # Now take the ratio of this amplitude to the wavelength
        # and see how it compares to the Hubble constant in Hz.
        # Why should there be a relation?  We are multiplying
        # by the Hubble time, to get the size of the effect
        # over the Hubble time - it appears commensurate
        # with the Hubble tension.
        h0 = cosmo.H0.to(1/u.s).value
        hubble_tension = np.array([
            x.value/h0 for x in self.fudge * energy / wavelengths])

        # Plot some stuff

        ax = await self.get()
        ax.set_title("Hubble Tension")
        ax.plot(wavelengths,  (1+hubble_tension) * self.cosmo.H0)
        ax.plot(wavelengths, [self.cosmo.H0.value] * len(wavelengths))
        ax.show()

        ax = await self.get()
        ax.set_title('planck radiance energy')
        ax.plot(wavelengths, energy)
        ax.show()
        
        ax = await self.get()
        ax.set_title("Schwartzschild Radius")
        ax.plot(wavelengths, sc)
        ax.show()
        
        
        ax = await self.get()
        ax.plot(wavelengths, energy)
        ax.set_title('Scaled energy')
        ax.show()

        # simulate the waves
        points, wave = waves(
            [x for x in energy],
            [x.value for x in wavelengths],
            period=self.period)

        ax = await self.get()
        ax.set_title('CMB generated gravity waves')
        ax.plot(points, wave)
        ax.show()
        
        ax = await self.get()
        ax.set_title('frequency v energy')
        ax.plot([c.c.value/x for x in points], energy)

        ax.show()



def waves(amplitudes, wavelengths, phases=None, period=1, n=1000):

    wave = np.zeros(n)

    if phases is None:
        phases = 2 * math.pi * np.random.random(n)
    
    points = np.linspace(0, period, n)

    for amplitude, wavelength, phase in zip(
            amplitudes, wavelengths, phases):
        wave += amplitude * np.sin((points/wavelength) + phase)

    return points, wave
                               

class Spiral(magic.Ball):
    """  Model a spiral galaxy

    Or any rotating mass?

    Want to convert this to use astropy units.
    """

    def __init__(self):

        super().__init__()

        self.modes = deque(
            ('galaxy', 'sun', 'sd'))

        # set up an initial mode
        self.cosmo = Cosmo()

        # need a way to calculate the density of the medium
        # and the temperature -- the two are linked.
        # this is for z and Eddington sphere calculations.
        self.n = 1e5  # density in protons / m**3 1e2 - 1e12
        self.T = 3000

        self.mode = None
        self.mode_switch()

        self.details = True

    def galaxy(self):
        """ Set parameters for a galaxy """
        # A = K * \omega_0.  K = M for Sciama principle
        # note 2 * A is the asymptotic tangential velocity
        self.A = 0.0005

        # Apparent rate of precession of the roots of the spiral.
        self.B = 0.00000015

        # Central mass.  Mass converted to Schwartzschild radius (in light years)
        # Mass of 1 is approximately 3e12 solar masses.
        self.Mcent = 0.03
        self.Mball = 0.
        self.Mdisc = 0.

        self.K = self.Mcent
        self.omega0 = self.A / self.K   # angular velocity in radians per year

        # magic constant determined by overall energy in the orbit
        self.EE = -0.00000345

        # constant, can be read from tangential velocity for small r
        self.CC = -10

        # range of radius r to consider, in light years
        self.rmin = 5000
        self.rmax = 50000


    def sun(self):

        print('SUN!' * 10)
        
        solar_angular_velocity = 2 * math.pi * 365 / 25  # radians per year
        
        # Central mass.  Mass converted to Schwartzschild radius (in light years)
        # Mass of 1 is approximately 3e12 solar masses.
        self.Mcent = (schwartzchild(c.M_sun) << u.lightyear).value
        self.Mball = 0.
        self.Mdisc = 0.
        self.omega0 = solar_angular_velocity # radians per year

        # astronomical unit in light years
        # au = 1 / 63241.08  ### can't remember how I calculated this
        auasly = u.au.to(u.lightyear)
        
        self.rmin = 0.1 * auasly
        self.rmax = 50 * auasly

        self.K = self.Mcent

        # solar wind goes from 30 km/s at 3 AU to 500 km/s at 40 AU
        # so set A to 2 * 500 km/s in our units
        # ??

        # A = K * \omega_0.  K = M for Sciama principle
        # want 2 * A to be 
        self.A = self.K * solar_angular_velocity

        # or go with asymptotic tangential velocity of 0.6km/h
        self.A = (((60 / 3600) * u.m/u.s) / c.c).value

        # magic constant determined by overall energy in the orbit
        self.EE = 5000


        # constant, can be read from tangential velocity for small r
        self.find_cc(tangential_velocity=self.rmin * self.omega0)
        #self.CC = -0.1

        # Apparent rate of precession of the roots of the spiral.
        self.B = self.A / self.rmin

        self.omega0 = self.A / self.K   # angular velocity in radians per year



    def sd(self):
        """ Spanish Dancer

        TODO: import values from sd module?
        """
        pass
        
    def print_parms(self):
        
        print('omega0', self.omega0)
        print('CC', self.CC)
        print('A/K', self.A / self.K)
        print('rmin_check', self.rmin_check())
        

    
    def find_cc(self, tangential_velocity):

        # constant, can be read from tangential velocity for small r
        A, K, r = self.A, self.K, self.rmin

        print(r, K, r/K)
        
        tv = (2 * A) - (2 * A *K) * math.log((r/K) + 1)

        self.CC = tangential_velocity - tv
        print('tv', tangential_velocity, self.CC, tv)

        return self.CC

    def rmin_check(self):
        """ The length of the roots of the spirals 

        This can be used to set the B value.

        Assume that the spiral roots end at radius r0

        And assume the roots are moving with the inertial frame at that
        radius.

        The rate of precession will match that of the inertial frame at
        that radius.

        """
        return self.A / self.B


    def v(self, r):
        """ Velocity at radius r 

        A = 0.0005
        K = Mcent
        CC = -10

        ??
        """
        A = self.A
        K = self.K
        CC = self.CC

        return (2 * A) - (2 * K * A * math.log(1 + K) / r) + CC / r


    def vinert(self, r, v):
        """ Inertial part of the velocity

        Part of velocity relative to inertial frame.

        Notes
        -----

        K is central mass.   A = 0.0005
        """
        return v - (self.A * r) / (self.K + r)

    def rdoubledot(self, r, vinert):

        rdd = ((vinert ** 2) / r) - (self.Mcent/(r**2))

        # if we have Mdisc of Mball, adjust as appropriate?
        rdd -= self.Mdisc/(self.rmax ** 2)
        rdd -= self.Mball * r /(self.rmax ** 3)

        return rdd

    def energy(self, r):

        CC = self.CC
        Mcent = self.Mcent
        Mdisc = self.Mdisc
        Mball = self.Mball
        rmax = self.rmax
        EE = self.EE
        K = self.K
        A = self.A
        Log = math.log

        # ok this deserves an explanation!
        energy = (-CC**2/(2*r**2) + (Mcent - 2*A*CC)/r -
                    # adjustment for a uniform disk radius rmax, mass Mdisc
                    Mdisc*r/rmax**2 +
                    # adjustment for a spherical mass
                    Mball*r**2/(2*rmax**3) +
                    # 
                    A**2*K/(K + r) +
                    A**2*Log(K + r) +
                    2 * A*K * (CC + 2*A*r) * Log(1 + r/K)/(r**2)
                    - (2 * A*K*Log(1 + r/K)/r)**2 + EE);
        
        return energy

    def mode_switch(self):

        if self.mode != self.modes[0]:
            self.mode = self.modes[0]
            # run the mode
            getattr(self, self.mode)()

    def spheres3(self):
        """ Bondi, Eddington and Schwartzchild

        We have mass in lightyears, the Schwartzchild radius.

        To get the mass in kilograms, S = 2GM/c^2, M = Sc^2/2G
        """
        T = self.T or 3000.
        S = self.Mcent # mass in lightyears, we need mass in kg

        M = self.lightyear_to_kg()

        msuns = M / c.M_sun
        print("mass in suns:", msuns)
        
        bondi = 2 * c.G * M * c.m_p / (3 * c.k_B * T)
        print('Bondi:', bondi.to(equivalencies=u.mass_energy()))
        self.bondi()
        print('Eddington:', 'TODO')
        print('Schwartzchild:', self.schwartzchild())

    def density(self):
        """ Return density of Mcent if it is a black hole """
        S = self.schwartzchild() << u.m
        M = S * c.c * c.c/ (2*c.G)
        
        M = M.to(u.kg, equivalencies=u.mass_energy())

        mpcm = (M / ((4/3) * math.pi * (S**3))) << u.kg / u.m**3

        return mpcm

    def amplitude(self, R=None):
        """amplitude of the gravitational wave wave

        Returns the amplitude of the wave if there was
        just one such object in the sphere radius R.  Scale
        by the actual density to get useful numbers.

        Suppose rho is the number of such objects per unit volume,
        the the full wave will be::

           a = 4 * pi rho Sum M r^2 dr / r for 0 < r < R

        Which simplifies to::

           a = 4 * pi * rho * M Sum r dr for 0 < r < R

        or:

            a = 2 * pi * rho * S * R ** 2  [1]

        Now::

            N = rho * 4/3 * pi * R**3

        So if N==1, rho = 4 * pi / (3* R**3), substituting in [1]

            a = 3 S / 2 R
        
        Where S be the Schwartzchild radius of Mcent.

        R is the radius out to which bodies can contribute to the sum.

        To get the full wave, scale by the number of objects in
        the region of radius R.

        """
        if R is None:
            R = self.cosmo.hubble_distance

        S = self.schwartzchild()
        amp = 3 * S / (2 * R)

        return amp
        

    def bondi(self):
        """ The Bondi Sphere
        
        Equate the root mean square velocity of hydrogen atoms in the
        medium,  sqrt(3kT/m_h) with the escape velocity sqrt(2GM/B).

        """
        # convert central mass to kg.
        # Mcent is actually schwartzchild radius in light years
        M = self.Mcent * u.lightyear.to(u.m) * u.m * c.c * c.c / (2 * c.G)
        print(f'Mass, # suns, S radius: {M} {M / c.M_sun:g} {self.Mcent}')
        B = 2 * c.G * M * c.m_p / (3 * c.k_B * self.T * u.K)

        #to(u.m*83/u.s**2, equivalencies=u.mass_energy())}")
        print(f"Bondi Radius {B}")
        print('escape velocity', math.sqrt((2 * c.G * M / B).value))

        # in natural units, c = G = 1, so we just need the mass of a
        # proton in natural units, but that is it's Schwartzchild
        # radius: 2GM/c^2
        m_p = (2 * c.m_p * c.G / (c.c*c.c)) << u.lightyear

        print(f'Schwartzchild radius of a proton {m_p}')

        Mcentm = self.Mcent * u.lightyear << u.m
        print('bondi in natural units???',
              2 * self.Mcent * u.lightyear * m_p / (3 * c.k_B * self.T))

        print('mean square velocity:',
              (3 * c.k_B * self.T * u.K / c.m_p).decompose())
        print('escape velocity squared:',
              (2 * c.G * M/B).decompose())
        
        print('Bondi Sphere:', B.decompose() << u.lightyear)
        return B.decompose()

    def eddington(self, z=None):
        """ Eddington Sphere

        Easiest to calculate if we know the redshift.
        """
        z = z or self.z_calc()
        
        return self.schwartzchild() / (1 - (1+z)**-2)
        

    def schwartzchild(self):
        """ Schwartzchild radius in lightyears """

        return self.Mcent * u.lightyear

    def lightyear_to_kg(self, m=None):

        m = m or self.Mcent
        # self.Mcent = 2 * M * c.G / (c.c * c.c)
        mass = m * u.lightyear * c.c * c.c / (2 * c.G)

        return mass.decompose()

    def z_calc(self):
        """ 1.27e7 theta / M

        M mass in suns
        """

        m = self.lightyear_to_kg() / c.M_sun

        theta =  (self.T**1.5)/ self.n

        return 1.27e7 * theta / m
    
        
    def critical_radius(self):
        """ Radius of Mcent based on critical density

        Convert Mcent to the radius of the sphere it
        would occupy based on critical density.
        """
        mass = self.lightyear_to_kg()

        cd = self.cosmo.critical_density0 << u.kg/u.m**3

        # M / ((4/3) pi r**3) = cd

        r = (3 * mass / (4*math.pi*cd))**(1/3)

        return r << u.lightyear

    async def run(self):

        # switch mode if it is time to do so
        self.mode_switch()

        self.spheres3()

        rr = np.linspace(self.rmin, self.rmax, 100)
        #vv = [self.v(r) for r in rr]
        vv = self.v(rr)
        ii = self.vinert(rr, vv)
        rdd = self.rdoubledot(rr, ii)
        energy = np.array([self.energy(r) for r in rr])
        #ii = [self.vinert(r, v) for (r, v) in zip(rr, vv)]
        #rdd = [self.rdoubledot(r, v) for (r, v) in zip(rr, ii)]
        rdot = np.sqrt(2 * energy)
        print('energy', max(energy), min(energy))
        #print('spiral', len(rr), len(rdot))

        if self.details:
            ax = await self.get()

            import statistics
            print(min(vv), max(vv),
                  statistics.mean(vv), statistics.variance(vv))
            ax.plot(rr, vv, label='velocity')
            ax.plot(rr, ii, label='vinert')
            ax.plot(rr, rdot, label='rdot')
            #ax.plot(rr, energy, label='energy')
            ax.legend(loc=0)
            ax.show()

            ax = await self.get()
            ax.plot(rr, rdd, label='rdoubledot')
            ax.legend(loc=0)
            ax.show()

        thetadot = vv/rr;

        dthetabydr = thetadot/rdot 
        dtbydr = 1/rdot

        NIntegrate = integrate.cumtrapz

        thetaValues = NIntegrate(dthetabydr, rr, initial=0.)
        tvalues = NIntegrate(dtbydr, rr, initial=0.)


        B = self.B
        ax = await self.get()
        # fixme - want polar projections - wibni this worked?
        ax.projection('polar')
        ax.plot(thetaValues - (B * tvalues), rr)
        ax.plot(thetaValues - (B * tvalues) + math.pi, rr)
        ax.axis('off')
        ax.show()


def pick(x, v, vmin, vmax):

    n = len(v)
    loc = n * (x - vmin) / vmax

    return v[loc]


def cpr():
    """  Started as Mathematica code from the new paradigm.
    
    adapted to python over time.

    See spiral class for more information over time.
    """

    Plot = plt.plot
    Log = np.log
    Sqrt = np.sqrt
    NIntegrate = integrate.cumtrapz
    
    A = 0.0005; Mcent = .03; EE = -.00000345; CC = -10;
    B = .00000015; Mball = 0; Mdisc = 0; K = Mcent;
    rmin = 5000; rmax = 50000; iterate = 1000;
    
    step = (rmax - rmin)/(iterate - 1)

    r = np.arange(rmin, rmax)

    ax = plt.subplot(121)

    v = 2*A - 2*K*A*Log(1 + r/K)/r + CC/r
    inert = v - A*r/(K + r);
    ax.plot(r, v, label='velocity')
    ax.plot(r, inert, label='vinert')
    
    rdoubledot = inert**2/r - Mcent/r**2 - Mdisc/rmax**2 - Mball*r/rmax**3
    ax.plot(r, rdoubledot, label='rdoubledot')

    energy = (-CC**2/(2*r**2) + (Mcent - 2*A*CC)/r -
                  Mdisc*r/rmax**2 +
                  Mball*r**2/(2*rmax**3) +
                  A**2*K/(K + r) +
                  A**2*Log(K + r) +
                  2 * A*K * (CC + 2*A*r) * Log(1 + r/K)/(r**2)
                  - (2 * A*K*Log(1 + r/K)/r)**2 + EE);
    #Plot(energy, r, label='energy')
    rdot = Sqrt(2*energy)

    ax.plot(r, rdot, label='rdot')

    ax.legend(loc=0)
    
    thetadot = v/r;
    dthetabydr = thetadot/rdot 
    dtbydr = 1/rdot

    
    thetaValues = NIntegrate(dthetabydr, r, initial=0.)
    print(thetaValues)
    print(len(thetaValues))

    tvalues = NIntegrate(dtbydr, r, initial=0.)

    #thetavalues = Table(
    #    NIntegrate(dthetabydr, rmin, rmax), ivalue, i, iterate))
    #tvalues = Table(
    #    NIntegrate(dtbydr, r, ivalue, i, iterate))
    
    #ListPolarPlot[{ Table[{thetavalues[[i]] - B*tvalues[[i]], ivalue},
    #{i, iterate}] ,
    #Table[{thetavalues[[i]] - B*tvalues[[i]] + Pi, ivalue},
    #{i, iterate}] }]

    print('theta', thetaValues[:5])
    ax = plt.subplot(122, projection='polar')
    ax.plot(thetaValues - (B * tvalues), r)
    ax.plot(thetaValues - (B * tvalues) + math.pi, r)

    values = (thetaValues - (B * tvalues))
    print(min(values), max(values))
    return rdot, inert, v, values


def near_galaxies():
    """ parse galaxy.txt from 

    https://heasarc.gsfc.nasa.gov/w3browse/all/neargalcat.html

    """
    from astroquery import heasarc
    from astropy import coordinates, table

    cached = Path('~/karmapi/heasarc.fits').expanduser()

    if cached.exists():
        table = table.Table.read(cached)
    else:
        heas = heasarc.Heasarc()

        coord = coordinates.SkyCoord('12h00m00 + 0d0m0s', frame='gcrs')
        table = heas.query_region(
            fields='All',
            mission='heasarc_neargalcat',
            position=coord,
            radius='360 deg')

        # write the cache if karmapi exists
        if cached.parent.exists():
            table.write(cached)

    for item in table:
        yield item

def schwartzchild(m):
    """ Mass in kg to schwartzchild radius in lightyears """
    return 2 * m * c.G / (c.c * c.c)

        
def from_heasarc(kwargs):
    """ Create a Spiral from a Heasarc record """
    galaxy = Spiral()

    # set mass to M26 mass
    m26 = 10 ** kwargs['LOG_MASS_26']
    mh1 = 10 ** kwargs['LOG_H1_MASS']

    print(m26)
    galaxy.Mstellar = m26
    galaxy.Mh1 = mh1
    galaxy.distance = kwargs['DISTANCE'] * u.Mpc << u.lightyear
    galaxy.dec = kwargs['DEC']
    galaxy.ra = kwargs['RA']
    galaxy.name = kwargs['NAME']

    return galaxy


def sample_galaxies(n=1000):

    # distribution of stellar mass based on heasarc catalog
    cosmo = Cosmo()
    hd = cosmo.hubble_distance
    
    stellar = statistics.NormalDist(
        mu=8.459767827529022,
        sigma=1.358427349161494)

    #h1 = NormalDist(mu=6.368135788262371, sigma=2.9859747769592895)

    for mass in stellar.samples(n):
        galaxy = Spiral()
        
        galaxy.Mstellar = 10**mass
        galaxy.distance = random.random() * hd << u.lightyear
        galaxy.dec = (random.random() * 180.0) - 90.0
        galaxy.ra = random.random() * 360.0
        galaxy.name = f'galaxy{n}'

        yield galaxy

    

def parse_radec(value):

    d, m, s = [float(s) for s in value.split()]

    scale = 1
    if d < 0:
        d *= -1
        scale = -1

    d += m / 60.
    d += s / 3600.

    return d * scale
    
def cleanse(data):

    clean = {}

    for key in data.keys():
        value = data[key]
        try:
            value = float(value)
        except:
            pass

        if key.lower() in ('ra', 'dec'):
            print(key, value)
            value = parse_radec(value)
            
        clean[key] = value

    return clean

async def run(**args):

    farm = fm.Farm()

    
    spiral = Spiral()
    farm.add(spiral)

    if args['skymap']:

        if args['heasarc']:
            galaxies = list(from_heasarc(x) for x in near_galaxies())
        else:
            print('creating a galaxy sample')
            galaxies = list(sample_galaxies(args['n']))
        
        skymap = SkyMap(galaxies)
        farm.add(skymap)


    await farm.start()
    print('about to run farm')
    await farm.run()


def main(args=None):

    parser = argparse.ArgumentParser()
    parser.add_argument('--skymap', action='store_true')
    parser.add_argument('--heasarc', action='store_true')
    parser.add_argument('-n', type=int, default=1000)

    args = parser.parse_args(args)

    magic.run(run(**args.__dict__))



if __name__ == '__main__':

    
 
    #cpr()
    #plt.show()
    main()
